# 票务系统架构文档

## 目录
1. [系统概述](#系统概述)
2. [数据模型设计](#数据模型设计)
3. [票的生命周期](#票的生命周期)
4. [核心业务流程](#核心业务流程)
5. [API 实现示例](#api-实现示例)
6. [常见问题处理](#常见问题处理)

---

## 系统概述

### 设计理念

**每张票都是独立实体，而不仅仅是一个数量统计。**

这个设计解决了以下核心问题：
1. ✅ 每张票可追踪（有唯一ID和票号）
2. ✅ 用户删除账号时票自动回到库存
3. ✅ 支持退票操作
4. ✅ 支持票的核销、转让等高级功能
5. ✅ 完整的票务审计追踪

### 新旧模型对比

#### ❌ 旧模型（基于数量统计）

```typescript
// Tier 表
{
  id: 1,
  name: "VIP票",
  capacity: 100,    // 总数
  remaining: 80     // 剩余
}

// Order 表
{
  id: "order-123",
  tierId: 1,
  qty: 2           // 只知道买了2张，不知道是哪两张
}
```

**问题：**
- ❌ 无法追踪具体的票
- ❌ 删除用户时库存无法自动恢复
- ❌ 退票很难实现
- ❌ 无法记录票的使用状态
- ❌ 无法实现票的转让

#### ✅ 新模型（每张票都是实体）

```typescript
// Tier 表（票档定义）
{
  id: 1,
  name: "VIP票",
  capacity: 100,
  remaining: 80
}

// Ticket 表（每张票都是独立记录）
{
  id: "uuid-001",
  ticketCode: "2024-VIP-001",
  tierId: 1,
  userId: "user-abc",
  orderId: "order-123",
  status: "sold",
  price: 299
}

// Order 表（订单）
{
  id: "order-123",
  userId: "user-abc",
  qty: 2,
  tickets: [Ticket #001, Ticket #002]  // 明确知道是哪两张票
}
```

---

## 数据模型设计

### 核心表结构

#### 1. Ticket 表（票）

```prisma
model Ticket {
  id          String    @id @default(uuid())
  ticketCode  String    @unique           // 票号（二维码/条形码）
  eventId     Int                         // 所属活动
  tierId      Int                         // 所属票档
  orderId     String?                     // 所属订单（库存中为空）
  userId      String?                     // 所属用户（库存中为空）
  status      String                      // 票的状态
  price       Int                         // 购买价格

  purchasedAt DateTime?                   // 购买时间
  usedAt      DateTime?                   // 使用时间
  refundedAt  DateTime?                   // 退款时间
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  order       Order?    @relation(fields: [orderId], references: [id], onDelete: SetNull)
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
}
```

**字段说明：**

| 字段 | 类型 | 说明 | 备注 |
|------|------|------|------|
| `id` | UUID | 票的唯一标识 | 主键 |
| `ticketCode` | String | 票号 | 唯一，用于二维码/条形码 |
| `eventId` | Int | 活动ID | 关联 Event 表 |
| `tierId` | Int | 票档ID | 关联 Tier 表 |
| `orderId` | String? | 订单ID | 可为空，库存中的票没有订单 |
| `userId` | String? | 用户ID | 可为空，库存中的票没有用户 |
| `status` | String | 票的状态 | 见下方状态说明 |
| `price` | Int | 购买价格 | 记录购买时的实际价格 |
| `purchasedAt` | DateTime? | 购买时间 | 支付成功时设置 |
| `usedAt` | DateTime? | 使用时间 | 核销时设置 |
| `refundedAt` | DateTime? | 退款时间 | 退票时设置 |

**票的状态（status）：**

| 状态 | 说明 | userId | orderId |
|------|------|--------|---------|
| `available` | 库存中可售 | null | null |
| `locked` | 已锁定（下单未支付） | null | 订单ID |
| `sold` | 已售出 | 用户ID | 订单ID |
| `used` | 已使用（已核销） | 用户ID | 订单ID |
| `refunded` | 已退款 | null | null |

#### 2. Order 表（订单）

```prisma
model Order {
  id        String    @id
  userId    String                        // 订单所属用户
  eventId   String
  tierId    String
  qty       Int                           // 购买数量
  holdId    String
  status    String                        // 订单状态
  createdAt BigInt
  paidAt    BigInt?

  user      User      @relation(fields: [userId], references: [id], onDelete: Restrict)
  tickets   Ticket[]                      // 订单包含的票
}
```

**重要变更：**
- ✅ 添加了 `tickets` 关联：可以查询订单包含哪些具体的票
- ✅ 用户外键改为 `Restrict`：有订单的用户不能直接删除

#### 3. User 表（用户）

```prisma
model User {
  id            String   @id @default(uuid())
  email         String?  @unique
  phone         String?  @unique
  // ... 其他字段

  orders        Order[]        // 用户的订单
  tickets       Ticket[]       // 用户的票
  loginLogs     LoginLog[]
  sessions      UserSession[]
}
```

**新增关联：**
- ✅ `tickets`：可以直接查询用户拥有的所有票

---

## 票的生命周期

### 完整流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                        票的生命周期                              │
└─────────────────────────────────────────────────────────────────┘

1. 创建票（主办方 → 公司库存）
   ┌─────────────────────────┐
   │ status: available       │
   │ userId: null            │
   │ orderId: null           │
   │ price: 299              │
   └─────────────────────────┘
            ↓

2. 用户下单（锁票，15分钟内支付）
   ┌─────────────────────────┐
   │ status: locked          │
   │ userId: null            │  ← 还没支付，不属于用户
   │ orderId: "order-123"    │
   └─────────────────────────┘
            ↓
     ┌─────┴─────┐
     ↓           ↓
   支付成功    支付超时
     ↓           ↓
     3          回到步骤1

3. 购买成功（票属于用户）
   ┌─────────────────────────┐
   │ status: sold            │
   │ userId: "user-abc"      │  ← 票现在属于用户
   │ orderId: "order-123"    │
   │ purchasedAt: 2024-10-30 │
   └─────────────────────────┘
            ↓
     ┌──────┴──────┐
     ↓             ↓
   使用票        退票
     ↓             ↓
     4             5

4. 使用票（核销）
   ┌─────────────────────────┐
   │ status: used            │
   │ userId: "user-abc"      │
   │ orderId: "order-123"    │
   │ usedAt: 2024-11-01      │
   └─────────────────────────┘
            ↓
        【结束】

5. 退票（票回到库存）
   ┌─────────────────────────┐
   │ status: refunded        │
   │ userId: null            │  ← 清空用户
   │ orderId: null           │  ← 清空订单
   │ refundedAt: 2024-10-31  │
   └─────────────────────────┘
            ↓
        回到步骤1
        （票可以再次售卖）

6. 删除用户（特殊情况）
   ┌─────────────────────────┐
   │ status: sold/refunded   │
   │ userId: null            │  ← 自动 SET NULL
   │ orderId: null           │  ← 自动 SET NULL
   └─────────────────────────┘
            ↓
        票自动回到库存！
```

---

## 核心业务流程

### 1. 主办方提供票给公司

**场景**：主办方提供100张VIP票给公司

```typescript
// scripts/create-tickets.ts
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

async function createTicketsForEvent(eventId: number, tierId: number, quantity: number, price: number) {
  console.log(`为活动 ${eventId} 创建 ${quantity} 张票...`);

  const tickets = [];
  for (let i = 1; i <= quantity; i++) {
    const ticketCode = `${eventId}-${tierId}-${String(i).padStart(4, '0')}`;

    tickets.push({
      ticketCode,
      eventId,
      tierId,
      status: 'available',
      price,
      userId: null,
      orderId: null,
    });
  }

  // 批量创建
  await prisma.ticket.createMany({
    data: tickets,
  });

  console.log(`✅ 成功创建 ${quantity} 张票`);
}

// 使用示例
createTicketsForEvent(1, 1, 100, 299);
```

### 2. 用户购买流程

#### Step 1: 查找可用的票

```typescript
// 查找指定数量的可用票
async function findAvailableTickets(tierId: number, quantity: number) {
  return await prisma.ticket.findMany({
    where: {
      tierId,
      status: 'available',
    },
    take: quantity,
    orderBy: {
      createdAt: 'asc',  // 先进先出
    },
  });
}
```

#### Step 2: 锁票（用户下单）

```typescript
// 用户下单，锁定票（15分钟内需支付）
async function lockTickets(ticketIds: string[], orderId: string) {
  await prisma.ticket.updateMany({
    where: {
      id: { in: ticketIds },
      status: 'available',  // 确保票仍然可用
    },
    data: {
      status: 'locked',
      orderId,
    },
  });

  // 设置15分钟后自动释放
  setTimeout(async () => {
    await releaseLockedTickets(orderId);
  }, 15 * 60 * 1000);
}

// 释放锁定的票（支付超时）
async function releaseLockedTickets(orderId: string) {
  await prisma.ticket.updateMany({
    where: {
      orderId,
      status: 'locked',
    },
    data: {
      status: 'available',
      orderId: null,
    },
  });
}
```

#### Step 3: 支付成功，分配票给用户

```typescript
// 支付成功后，将票分配给用户
async function assignTicketsToUser(orderId: string, userId: string) {
  await prisma.ticket.updateMany({
    where: {
      orderId,
      status: 'locked',
    },
    data: {
      status: 'sold',
      userId,
      purchasedAt: new Date(),
    },
  });
}
```

#### 完整的购票 API

```typescript
// app/api/tickets/purchase/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function POST(req: NextRequest) {
  try {
    const { userId, tierId, quantity } = await req.json();

    // 1. 查找可用的票
    const availableTickets = await prisma.ticket.findMany({
      where: {
        tierId,
        status: 'available',
      },
      take: quantity,
    });

    if (availableTickets.length < quantity) {
      return NextResponse.json(
        { ok: false, error: '可用票数不足' },
        { status: 400 }
      );
    }

    // 2. 创建订单
    const orderId = `order-${Date.now()}`;
    const order = await prisma.order.create({
      data: {
        id: orderId,
        userId,
        tierId: String(tierId),
        qty: quantity,
        status: 'pending',
        createdAt: BigInt(Date.now()),
        // ... 其他字段
      },
    });

    // 3. 锁定票
    const ticketIds = availableTickets.map(t => t.id);
    await prisma.ticket.updateMany({
      where: {
        id: { in: ticketIds },
      },
      data: {
        status: 'locked',
        orderId,
      },
    });

    return NextResponse.json({
      ok: true,
      data: {
        orderId,
        tickets: availableTickets,
        expireAt: Date.now() + 15 * 60 * 1000,  // 15分钟后过期
      },
    });
  } catch (error: any) {
    console.error('购票失败:', error);
    return NextResponse.json(
      { ok: false, error: '购票失败' },
      { status: 500 }
    );
  }
}
```

### 3. 查询用户的票

```typescript
// 查询用户拥有的所有票
async function getUserTickets(userId: string) {
  return await prisma.ticket.findMany({
    where: {
      userId,
      status: { in: ['sold', 'used'] },  // 已购买或已使用的票
    },
    include: {
      order: true,  // 包含订单信息
    },
    orderBy: {
      purchasedAt: 'desc',
    },
  });
}

// API 实现
export async function GET(req: NextRequest) {
  const userId = req.headers.get('user-id');  // 从 token 中获取

  const tickets = await getUserTickets(userId);

  return NextResponse.json({
    ok: true,
    data: tickets,
  });
}
```

### 4. 退票流程

```typescript
// 退票：票回到库存
async function refundTicket(ticketId: string, userId: string) {
  // 验证票是否属于该用户
  const ticket = await prisma.ticket.findFirst({
    where: {
      id: ticketId,
      userId,
      status: 'sold',  // 只能退已售出的票
    },
  });

  if (!ticket) {
    throw new Error('票不存在或已使用');
  }

  // 更新票的状态
  await prisma.ticket.update({
    where: { id: ticketId },
    data: {
      status: 'refunded',
      userId: null,       // 清空用户
      orderId: null,      // 清空订单
      refundedAt: new Date(),
    },
  });

  // 更新订单状态
  await prisma.order.update({
    where: { id: ticket.orderId! },
    data: {
      status: 'refunded',
    },
  });

  return { success: true, ticket };
}

// API 实现
export async function POST(req: NextRequest) {
  const { ticketId, userId } = await req.json();

  try {
    const result = await refundTicket(ticketId, userId);

    return NextResponse.json({
      ok: true,
      message: '退票成功，票已回到库存',
      data: result,
    });
  } catch (error: any) {
    return NextResponse.json(
      { ok: false, error: error.message },
      { status: 400 }
    );
  }
}
```

### 5. 票的核销（使用）

```typescript
// 核销票（扫码验票）
async function verifyTicket(ticketCode: string) {
  const ticket = await prisma.ticket.findUnique({
    where: { ticketCode },
    include: {
      user: true,
      order: true,
    },
  });

  if (!ticket) {
    return { success: false, error: '票不存在' };
  }

  if (ticket.status === 'used') {
    return { success: false, error: '票已使用' };
  }

  if (ticket.status !== 'sold') {
    return { success: false, error: '票状态异常' };
  }

  // 标记为已使用
  await prisma.ticket.update({
    where: { id: ticket.id },
    data: {
      status: 'used',
      usedAt: new Date(),
    },
  });

  return {
    success: true,
    message: '验票成功',
    ticket,
  };
}

// API 实现
export async function POST(req: NextRequest) {
  const { ticketCode } = await req.json();

  const result = await verifyTicket(ticketCode);

  if (!result.success) {
    return NextResponse.json(
      { ok: false, error: result.error },
      { status: 400 }
    );
  }

  return NextResponse.json({
    ok: true,
    message: result.message,
    data: result.ticket,
  });
}
```

### 6. 删除用户账号

```typescript
// 删除用户前的处理
async function deleteUserAccount(userId: string) {
  // 1. 检查是否有未使用的票
  const unusedTickets = await prisma.ticket.findMany({
    where: {
      userId,
      status: 'sold',  // 已购买但未使用
    },
  });

  if (unusedTickets.length > 0) {
    // 选项A：不允许删除
    throw new Error(`用户还有 ${unusedTickets.length} 张未使用的票，无法删除账号`);

    // 选项B：自动退票
    // await prisma.ticket.updateMany({
    //   where: { id: { in: unusedTickets.map(t => t.id) } },
    //   data: {
    //     status: 'refunded',
    //     userId: null,
    //     orderId: null,
    //     refundedAt: new Date(),
    //   },
    // });
  }

  // 2. 删除用户（票会自动 SET NULL，回到库存）
  await prisma.user.delete({
    where: { id: userId },
  });

  // 3. 票的 userId 自动变为 null（数据库外键自动处理）
  // 这些票可以被再次售卖
}
```

---

## 常见问题处理

### Q1: 如何查询库存中的可用票数？

```typescript
// 方法1：直接统计
const availableCount = await prisma.ticket.count({
  where: {
    tierId: 1,
    status: 'available',
  },
});

// 方法2：按活动分组统计
const inventory = await prisma.ticket.groupBy({
  by: ['eventId', 'tierId', 'status'],
  _count: true,
  where: {
    eventId: 1,
  },
});
```

### Q2: 如何防止超卖？

```typescript
// 使用数据库事务确保原子性
async function purchaseTickets(userId: string, tierId: number, quantity: number) {
  return await prisma.$transaction(async (tx) => {
    // 1. 锁定查询可用票
    const availableTickets = await tx.ticket.findMany({
      where: {
        tierId,
        status: 'available',
      },
      take: quantity,
      // PostgreSQL 行级锁
      // SELECT ... FOR UPDATE
    });

    if (availableTickets.length < quantity) {
      throw new Error('库存不足');
    }

    // 2. 创建订单
    const order = await tx.order.create({
      data: { /* ... */ },
    });

    // 3. 更新票状态
    await tx.ticket.updateMany({
      where: {
        id: { in: availableTickets.map(t => t.id) },
      },
      data: {
        status: 'locked',
        orderId: order.id,
      },
    });

    return { order, tickets: availableTickets };
  });
}
```

### Q3: 如何批量导入票？

```typescript
// 批量创建票（效率更高）
async function bulkCreateTickets(eventId: number, tierId: number, count: number, price: number) {
  const batchSize = 1000;  // 每次插入1000条

  for (let i = 0; i < count; i += batchSize) {
    const batch = [];
    const end = Math.min(i + batchSize, count);

    for (let j = i; j < end; j++) {
      batch.push({
        ticketCode: `${eventId}-${tierId}-${String(j + 1).padStart(6, '0')}`,
        eventId,
        tierId,
        status: 'available',
        price,
      });
    }

    await prisma.ticket.createMany({
      data: batch,
    });

    console.log(`已创建 ${end}/${count} 张票`);
  }
}
```

### Q4: 如何实现票的转让？

```typescript
// 将票转让给其他用户
async function transferTicket(ticketId: string, fromUserId: string, toUserId: string) {
  // 1. 验证票属于原用户
  const ticket = await prisma.ticket.findFirst({
    where: {
      id: ticketId,
      userId: fromUserId,
      status: 'sold',
    },
  });

  if (!ticket) {
    throw new Error('票不存在或无法转让');
  }

  // 2. 转让给新用户
  await prisma.ticket.update({
    where: { id: ticketId },
    data: {
      userId: toUserId,
      updatedAt: new Date(),
    },
  });

  // 3. 记录转让日志（可选）
  await prisma.ticketTransferLog.create({
    data: {
      ticketId,
      fromUserId,
      toUserId,
      transferredAt: new Date(),
    },
  });
}
```

### Q5: 如何生成票号（ticketCode）？

```typescript
// 票号生成规则示例
function generateTicketCode(eventId: number, tierId: number, sequence: number): string {
  const year = new Date().getFullYear();
  const eventPrefix = String(eventId).padStart(4, '0');
  const tierPrefix = String(tierId).padStart(2, '0');
  const seqNumber = String(sequence).padStart(6, '0');

  // 格式：2024-0001-01-000001
  return `${year}-${eventPrefix}-${tierPrefix}-${seqNumber}`;
}

// 带校验码的票号
function generateTicketCodeWithChecksum(eventId: number, tierId: number, sequence: number): string {
  const base = `${eventId}${tierId}${sequence}`;
  const checksum = calculateChecksum(base);  // 自定义校验算法

  return `${eventId}-${tierId}-${sequence}-${checksum}`;
}
```

### Q6: 如何查询某场活动的票务统计？

```typescript
// 查询活动的票务统计
async function getEventTicketStats(eventId: number) {
  const stats = await prisma.ticket.groupBy({
    by: ['status'],
    where: { eventId },
    _count: true,
  });

  return {
    total: stats.reduce((sum, s) => sum + s._count, 0),
    available: stats.find(s => s.status === 'available')?._count || 0,
    locked: stats.find(s => s.status === 'locked')?._count || 0,
    sold: stats.find(s => s.status === 'sold')?._count || 0,
    used: stats.find(s => s.status === 'used')?._count || 0,
    refunded: stats.find(s => s.status === 'refunded')?._count || 0,
  };
}
```

---

## API 快速参考

### 票务相关 API

| API | 方法 | 说明 |
|-----|------|------|
| `/api/tickets/create` | POST | 创建票（主办方） |
| `/api/tickets/available` | GET | 查询可用票 |
| `/api/tickets/purchase` | POST | 购买票 |
| `/api/tickets/my-tickets` | GET | 查询我的票 |
| `/api/tickets/refund` | POST | 退票 |
| `/api/tickets/verify` | POST | 核销票 |
| `/api/tickets/transfer` | POST | 转让票 |
| `/api/tickets/stats` | GET | 票务统计 |

---

## 数据库维护

### 定期清理任务

```typescript
// 清理超时锁定的票（定时任务）
async function cleanupExpiredLocks() {
  const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000);

  await prisma.ticket.updateMany({
    where: {
      status: 'locked',
      updatedAt: {
        lt: fifteenMinutesAgo,
      },
    },
    data: {
      status: 'available',
      orderId: null,
    },
  });
}

// 每5分钟执行一次
setInterval(cleanupExpiredLocks, 5 * 60 * 1000);
```

### 数据备份

```bash
# 备份票务数据
pg_dump -U postgres -d piaociyuan -t tickets -t orders -t users > backup.sql

# 恢复
psql -U postgres -d piaociyuan < backup.sql
```

---

## 总结

### 核心优势

1. **每张票都可追踪**
   - 唯一ID和票号
   - 完整的生命周期记录

2. **自动库存管理**
   - 删除用户时票自动回库
   - 退票时票自动回库

3. **灵活的业务支持**
   - 支持退票
   - 支持转让
   - 支持核销
   - 支持多种状态管理

4. **数据完整性**
   - 外键约束保证数据一致性
   - 事务保证操作原子性

### 最佳实践

1. ✅ 使用事务处理复杂操作
2. ✅ 定期清理超时锁定的票
3. ✅ 记录完整的审计日志
4. ✅ 使用唯一票号防止伪造
5. ✅ 批量操作提高性能

---

## 相关文档

- [PostgreSQL 迁移指南](./postgresql-migration-guide.md)
- [用户数据存储最佳实践](./user-data-storage-best-practices.md)
- [数据库查询手册](./database-queries.md)

---

**文档版本**: 1.0
**最后更新**: 2025-10-30
**维护者**: 系统架构团队
