/**
 * æ´»åŠ¨çŠ¶æ€å·¥å…·å‡½æ•°
 */

// å”®ç¥¨çŠ¶æ€
export type SaleStatus = 'not_started' | 'on_sale' | 'paused' | 'sold_out' | 'ended';

// æ´»åŠ¨è¿›è¡ŒçŠ¶æ€
export type EventStatus = 'upcoming' | 'ongoing' | 'ended';

export type EventCategory = 'concert' | 'festival' | 'exhibition' | 'musicale' | 'show' | 'sports' | 'other';

/**
 * æ´»åŠ¨ç±»å‹æ ‡ç­¾æ˜ å°„
 */
export const EVENT_CATEGORY_LABELS: Record<EventCategory, string> = {
  concert: 'æ¼”å”±ä¼š',
  festival: 'éŸ³ä¹èŠ‚',
  exhibition: 'å±•è§ˆ',
  musicale: 'éŸ³ä¹ä¼š',
  show: 'æ¼”å‡º',
  sports: 'ä½“è‚²èµ›äº‹',
  other: 'å…¶ä»–',
};

/**
 * æ´»åŠ¨ç±»å‹å›¾æ ‡æ˜ å°„
 */
export const EVENT_CATEGORY_ICONS: Record<EventCategory, string> = {
  concert: 'ğŸ¤',
  festival: 'ğŸª',
  exhibition: 'ğŸ¨',
  musicale: 'ğŸ»',
  show: 'ğŸ­',
  sports: 'âš½',
  other: 'ğŸ“…',
};

/**
 * æ´»åŠ¨ç±»å‹é¢œè‰²æ˜ å°„
 */
export const EVENT_CATEGORY_COLORS: Record<EventCategory, string> = {
  concert: 'bg-purple-100 text-purple-800',
  festival: 'bg-pink-100 text-pink-800',
  exhibition: 'bg-blue-100 text-blue-800',
  musicale: 'bg-indigo-100 text-indigo-800',
  show: 'bg-amber-100 text-amber-800',
  sports: 'bg-green-100 text-green-800',
  other: 'bg-gray-100 text-gray-800',
};

// å”®ç¥¨çŠ¶æ€æ ‡ç­¾æ˜ å°„
export const SALE_STATUS_LABELS: Record<SaleStatus, string> = {
  not_started: 'æœªå¼€å”®',
  on_sale: 'å”®ç¥¨ä¸­',
  paused: 'æš‚åœå”®ç¥¨',
  sold_out: 'å·²å”®ç½„',
  ended: 'å·²ç»“æŸ',
};

export const SALE_STATUS_COLORS: Record<SaleStatus, string> = {
  not_started: 'bg-gray-100 text-gray-700',
  on_sale: 'bg-green-100 text-green-700',
  paused: 'bg-yellow-100 text-yellow-700',
  sold_out: 'bg-red-100 text-red-700',
  ended: 'bg-gray-100 text-gray-500',
};

export interface EventStatusInfo {
  status: EventStatus;
  label: string;
  canPurchase: boolean;
  color: string;
}

export interface SaleStatusInfo {
  saleStatus: SaleStatus;
  label: string;
  canPurchase: boolean;
  color: string;
  reason?: string;  // ä¸èƒ½è´­ç¥¨çš„åŸå› 
}

/**
 * è·å–å”®ç¥¨çŠ¶æ€ä¿¡æ¯ï¼ˆæ–°ç‰ˆ - åŸºäºæ•°æ®åº“å­—æ®µï¼‰
 * @param saleStatus æ•°æ®åº“ä¸­çš„å”®ç¥¨çŠ¶æ€
 * @param saleStartTime å¼€å”®æ—¶é—´
 * @param saleEndTime åœå”®æ—¶é—´
 * @param remaining å‰©ä½™ç¥¨æ•°ï¼ˆå¯é€‰ï¼Œç”¨äºåˆ¤æ–­sold_outï¼‰
 * @returns å”®ç¥¨çŠ¶æ€ä¿¡æ¯
 */
export function getSaleStatusInfo(
  saleStatus: string,
  saleStartTime: Date | string,
  saleEndTime: Date | string,
  remaining?: number
): SaleStatusInfo {
  const now = new Date();
  const startTime = typeof saleStartTime === 'string' ? new Date(saleStartTime) : saleStartTime;
  const endTime = typeof saleEndTime === 'string' ? new Date(saleEndTime) : saleEndTime;

  // 1. æ£€æŸ¥ç®¡ç†å‘˜æ‰‹åŠ¨è®¾ç½®çš„çŠ¶æ€
  if (saleStatus === 'paused') {
    return {
      saleStatus: 'paused',
      label: SALE_STATUS_LABELS.paused,
      canPurchase: false,
      color: SALE_STATUS_COLORS.paused,
      reason: 'æ´»åŠ¨æš‚åœå”®ç¥¨',
    };
  }

  if (saleStatus === 'sold_out') {
    return {
      saleStatus: 'sold_out',
      label: SALE_STATUS_LABELS.sold_out,
      canPurchase: false,
      color: SALE_STATUS_COLORS.sold_out,
      reason: 'é—¨ç¥¨å·²å”®ç½„',
    };
  }

  if (saleStatus === 'ended') {
    return {
      saleStatus: 'ended',
      label: SALE_STATUS_LABELS.ended,
      canPurchase: false,
      color: SALE_STATUS_COLORS.ended,
      reason: 'æ´»åŠ¨å·²ç»“æŸ',
    };
  }

  // 2. æ£€æŸ¥å‰©ä½™ç¥¨æ•°
  if (remaining !== undefined && remaining === 0) {
    return {
      saleStatus: 'sold_out',
      label: SALE_STATUS_LABELS.sold_out,
      canPurchase: false,
      color: SALE_STATUS_COLORS.sold_out,
      reason: 'é—¨ç¥¨å·²å”®ç½„',
    };
  }

  // 3. æ£€æŸ¥æ—¶é—´èŒƒå›´
  if (now < startTime) {
    return {
      saleStatus: 'not_started',
      label: SALE_STATUS_LABELS.not_started,
      canPurchase: false,
      color: SALE_STATUS_COLORS.not_started,
      reason: `å”®ç¥¨å°†äº ${formatDateTime(startTime)} å¼€å§‹`,
    };
  }

  if (now > endTime) {
    return {
      saleStatus: 'ended',
      label: SALE_STATUS_LABELS.ended,
      canPurchase: false,
      color: SALE_STATUS_COLORS.ended,
      reason: 'å”®ç¥¨å·²ç»“æŸ',
    };
  }

  // 4. æ­£åœ¨å”®ç¥¨ä¸­
  return {
    saleStatus: 'on_sale',
    label: SALE_STATUS_LABELS.on_sale,
    canPurchase: true,
    color: SALE_STATUS_COLORS.on_sale,
  };
}

/**
 * æ ¼å¼åŒ–æ—¥æœŸæ—¶é—´
 */
function formatDateTime(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hour = String(date.getHours()).padStart(2, '0');
  const minute = String(date.getMinutes()).padStart(2, '0');
  return `${year}-${month}-${day} ${hour}:${minute}`;
}

/**
 * åˆ¤æ–­æ´»åŠ¨æ˜¯å¦å·²è¿‡æœŸï¼ˆæ—§ç‰ˆ - ä¿ç•™ç”¨äºå…¼å®¹ï¼‰
 * @param dateString æ—¥æœŸå­—ç¬¦ä¸²ï¼Œæ ¼å¼å¦‚ "2025-01-15"
 * @param timeString æ—¶é—´å­—ç¬¦ä¸²ï¼Œæ ¼å¼å¦‚ "19:30"
 * @returns æ´»åŠ¨çŠ¶æ€ä¿¡æ¯
 */
export function getEventStatus(dateString: string, timeString: string): EventStatusInfo {
  try {
    // è§£ææ´»åŠ¨æ—¥æœŸå’Œæ—¶é—´
    const eventDateTimeStr = `${dateString} ${timeString}`;
    const eventDateTime = new Date(eventDateTimeStr);

    // å¦‚æœè§£æå¤±è´¥ï¼Œè¿”å›é»˜è®¤çŠ¶æ€
    if (isNaN(eventDateTime.getTime())) {
      console.warn(`Invalid date format: ${dateString} ${timeString}`);
      return {
        status: 'upcoming',
        label: 'å³å°†å¼€å§‹',
        canPurchase: true,
        color: 'blue',
      };
    }

    const now = new Date();

    // æ´»åŠ¨ç»“æŸæ—¶é—´ï¼ˆå‡è®¾æ´»åŠ¨æŒç»­3å°æ—¶ï¼‰
    const eventEndTime = new Date(eventDateTime.getTime() + 3 * 60 * 60 * 1000);

    if (now > eventEndTime) {
      // æ´»åŠ¨å·²ç»“æŸ
      return {
        status: 'ended',
        label: 'å·²ç»“æŸ',
        canPurchase: false,
        color: 'gray',
      };
    } else if (now >= eventDateTime && now <= eventEndTime) {
      // æ´»åŠ¨è¿›è¡Œä¸­
      return {
        status: 'ongoing',
        label: 'è¿›è¡Œä¸­',
        canPurchase: false,
        color: 'green',
      };
    } else {
      // å³å°†å¼€å§‹
      return {
        status: 'upcoming',
        label: 'å³å°†å¼€å§‹',
        canPurchase: true,
        color: 'blue',
      };
    }
  } catch (error) {
    console.error('Error parsing event date:', error);
    return {
      status: 'upcoming',
      label: 'å³å°†å¼€å§‹',
      canPurchase: true,
      color: 'blue',
    };
  }
}

/**
 * åˆ¤æ–­æ´»åŠ¨æ˜¯å¦å¯ä»¥è´­ç¥¨
 * @param dateString æ—¥æœŸå­—ç¬¦ä¸²
 * @param timeString æ—¶é—´å­—ç¬¦ä¸²
 * @returns æ˜¯å¦å¯ä»¥è´­ç¥¨
 */
export function canPurchaseTickets(dateString: string, timeString: string): boolean {
  const statusInfo = getEventStatus(dateString, timeString);
  return statusInfo.canPurchase;
}

/**
 * åˆ¤æ–­æ´»åŠ¨æ˜¯å¦å·²ç»“æŸ
 * @param dateString æ—¥æœŸå­—ç¬¦ä¸²
 * @param timeString æ—¶é—´å­—ç¬¦ä¸²
 * @returns æ˜¯å¦å·²ç»“æŸ
 */
export function isEventEnded(dateString: string, timeString: string): boolean {
  const statusInfo = getEventStatus(dateString, timeString);
  return statusInfo.status === 'ended';
}

/**
 * æ ¼å¼åŒ–æ´»åŠ¨æ—¥æœŸæ˜¾ç¤º
 * @param dateString æ—¥æœŸå­—ç¬¦ä¸²
 * @param timeString æ—¶é—´å­—ç¬¦ä¸²
 * @returns æ ¼å¼åŒ–çš„æ—¥æœŸæ—¶é—´å­—ç¬¦ä¸²
 */
export function formatEventDateTime(dateString: string, timeString: string): string {
  try {
    const eventDateTime = new Date(`${dateString} ${timeString}`);
    if (isNaN(eventDateTime.getTime())) {
      return `${dateString} ${timeString}`;
    }

    const year = eventDateTime.getFullYear();
    const month = String(eventDateTime.getMonth() + 1).padStart(2, '0');
    const day = String(eventDateTime.getDate()).padStart(2, '0');
    const weekdays = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
    const weekday = weekdays[eventDateTime.getDay()];

    return `${year}å¹´${month}æœˆ${day}æ—¥ ${weekday} ${timeString}`;
  } catch (error) {
    return `${dateString} ${timeString}`;
  }
}

/**
 * è·å–æ´»åŠ¨å€’è®¡æ—¶ä¿¡æ¯
 * @param dateString æ—¥æœŸå­—ç¬¦ä¸²
 * @param timeString æ—¶é—´å­—ç¬¦ä¸²
 * @returns å€’è®¡æ—¶æ–‡æœ¬
 */
export function getEventCountdown(dateString: string, timeString: string): string | null {
  try {
    const eventDateTime = new Date(`${dateString} ${timeString}`);
    if (isNaN(eventDateTime.getTime())) {
      return null;
    }

    const now = new Date();
    const diff = eventDateTime.getTime() - now.getTime();

    if (diff <= 0) {
      return null;
    }

    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));

    if (days > 0) {
      return `è·ç¦»å¼€å§‹è¿˜æœ‰ ${days} å¤©`;
    } else if (hours > 0) {
      return `è·ç¦»å¼€å§‹è¿˜æœ‰ ${hours} å°æ—¶`;
    } else {
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      return `è·ç¦»å¼€å§‹è¿˜æœ‰ ${minutes} åˆ†é’Ÿ`;
    }
  } catch (error) {
    return null;
  }
}
