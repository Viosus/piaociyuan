// app/api/orders/route.ts
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { genId, normalizeId } from "@/lib/store";
import { purgeExpiredHolds, ApiError } from "@/lib/inventory";

// âœ… è®¢å•åˆ—è¡¨æŸ¥è¯¢ï¼ˆæ”¯æŒåˆ†é¡µã€ç­›é€‰ã€æœç´¢ã€æ’åºï¼‰
export async function GET(req: Request) {
  try {
    console.log("[ORDER_LIST] ğŸ“‹ å¼€å§‹æŸ¥è¯¢è®¢å•åˆ—è¡¨");
    
    const { searchParams } = new URL(req.url);
    
    // ğŸ“„ åˆ†é¡µå‚æ•°
    const page = Math.max(1, parseInt(searchParams.get("page") || "1"));
    const pageSize = Math.max(1, Math.min(100, parseInt(searchParams.get("pageSize") || "10")));
    
    // ğŸ” ç­›é€‰å‚æ•°
    const statusFilter = searchParams.get("status"); // PENDING | PAID
    const eventIdFilter = searchParams.get("eventId"); // æ´»åŠ¨ ID
    const searchQuery = searchParams.get("q")?.trim(); // æœç´¢å…³é”®è¯
    
    // ğŸ“… æ—¶é—´èŒƒå›´ï¼ˆæ—¶é—´æˆ³æ ¼å¼ï¼‰
    const startDateStr = searchParams.get("startDate");
    const endDateStr = searchParams.get("endDate");
    
    // ğŸ’° é‡‘é¢èŒƒå›´
    const minAmountStr = searchParams.get("minAmount");
    const maxAmountStr = searchParams.get("maxAmount");
    
    // ğŸ“Š æ’åºå‚æ•°
    const sortBy = searchParams.get("sortBy") || "createdAt"; // createdAt | paidAt | amount
    const sortOrder = searchParams.get("sortOrder") || "desc"; // asc | desc
    
    console.log(`[ORDER_LIST] æŸ¥è¯¢å‚æ•°:`, {
      page,
      pageSize,
      status: statusFilter || "å…¨éƒ¨",
      eventId: eventIdFilter || "å…¨éƒ¨",
      search: searchQuery || "æ— ",
      sortBy,
      sortOrder,
    });

    // ğŸ”¨ æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const where: any = {};
    
    // çŠ¶æ€ç­›é€‰
    if (statusFilter && (statusFilter === "PENDING" || statusFilter === "PAID")) {
      where.status = statusFilter;
    }
    
    // æ´»åŠ¨ç­›é€‰
    if (eventIdFilter) {
      where.eventId = normalizeId(eventIdFilter);
    }
    
    // æ—¶é—´èŒƒå›´ç­›é€‰
    if (startDateStr || endDateStr) {
      where.createdAt = {};
      if (startDateStr) {
        const startTimestamp = new Date(startDateStr).getTime();
        if (!isNaN(startTimestamp)) {
          where.createdAt.gte = BigInt(startTimestamp);
        }
      }
      if (endDateStr) {
        const endTimestamp = new Date(endDateStr).getTime();
        if (!isNaN(endTimestamp)) {
          // ç»“æŸæ—¥æœŸåŒ…å«å½“å¤©çš„ 23:59:59
          where.createdAt.lte = BigInt(endTimestamp + 24 * 60 * 60 * 1000 - 1);
        }
      }
    }
    
    // æœç´¢åŠŸèƒ½ï¼ˆè®¢å•å·æ¨¡ç³ŠåŒ¹é…ï¼‰
    if (searchQuery) {
      where.id = {
        contains: searchQuery,
        mode: 'insensitive' as any,
      };
    }

    // ğŸ” ç¬¬ä¸€æ­¥ï¼šæŸ¥è¯¢è®¢å•ï¼ˆåŒ…å«å…³è”çš„æ´»åŠ¨å’Œç¥¨æ¡£ä¿¡æ¯ï¼Œé¿å… N+1 æŸ¥è¯¢ï¼‰
    const [orders, total] = await Promise.all([
      prisma.order.findMany({
        where,
        skip: (page - 1) * pageSize,
        take: pageSize,
        orderBy: 
          sortBy === "paidAt" 
            ? { paidAt: sortOrder as "asc" | "desc" }
            : { createdAt: sortOrder as "asc" | "desc" },
        include: {
          // è¿™é‡Œå‡è®¾ä½ çš„ Prisma schema æ²¡æœ‰å®šä¹‰å…³ç³»
          // å¦‚æœæœ‰å®šä¹‰å…³ç³»ï¼Œå¯ä»¥ç›´æ¥ include: { event: true, tier: true }
        },
      }),
      prisma.order.count({ where }),
    ]);

    console.log(`[ORDER_LIST] âœ… æŸ¥è¯¢ç»“æœ: ${orders.length}/${total} æ¡`);

    // ğŸ¯ ç¬¬äºŒæ­¥ï¼šæ‰¹é‡è·å–æ´»åŠ¨å’Œç¥¨æ¡£ä¿¡æ¯ï¼ˆä¼˜åŒ–æ€§èƒ½ï¼‰
    const eventIds = [...new Set(orders.map(o => o.eventId))];
    const tierIds = [...new Set(orders.map(o => o.tierId))];
    
    const [events, tiers] = await Promise.all([
      prisma.event.findMany({
        where: { id: { in: eventIds.map(id => parseInt(id)) } },
        select: { id: true, name: true, city: true, date: true, time: true },
      }),
      prisma.tier.findMany({
        where: { id: { in: tierIds.map(id => parseInt(id)) } },
        select: { id: true, name: true, price: true },
      }),
    ]);
    
    // åˆ›å»ºæ˜ å°„è¡¨ä»¥ä¾¿å¿«é€ŸæŸ¥æ‰¾
    const eventMap = new Map(events.map(e => [String(e.id), e]));
    const tierMap = new Map(tiers.map(t => [String(t.id), t]));

    // ğŸ¨ ç¬¬ä¸‰æ­¥ï¼šç»„è£…æ•°æ®å¹¶åº”ç”¨é‡‘é¢ç­›é€‰
    let result = orders.map((order) => {
      const event = eventMap.get(order.eventId);
      const tier = tierMap.get(order.tierId);
      const amount = tier ? tier.price * order.qty : 0;
      
      return {
        id: order.id,
        eventId: Number(order.eventId),
        tierId: Number(order.tierId),
        qty: order.qty,
        status: order.status,
        createdAt: Number(order.createdAt),
        paidAt: order.paidAt ? Number(order.paidAt) : null,
        holdId: order.holdId,
        // é™„åŠ ä¿¡æ¯
        event: event ? {
          id: event.id,
          name: event.name,
          city: event.city,
          date: event.date,
          time: event.time,
        } : undefined,
        tier: tier ? {
          id: tier.id,
          name: tier.name,
          price: tier.price,
        } : undefined,
        amount, // è®¢å•æ€»é‡‘é¢
      };
    });
    
    // ğŸ’° é‡‘é¢ç­›é€‰ï¼ˆåœ¨å†…å­˜ä¸­è¿‡æ»¤ï¼Œå› ä¸ºé‡‘é¢æ˜¯è®¡ç®—å­—æ®µï¼‰
    if (minAmountStr || maxAmountStr) {
      const minAmount = minAmountStr ? parseFloat(minAmountStr) : -Infinity;
      const maxAmount = maxAmountStr ? parseFloat(maxAmountStr) : Infinity;
      
      result = result.filter(order => {
        return order.amount >= minAmount && order.amount <= maxAmount;
      });
    }
    
    // ğŸ’° é‡‘é¢æ’åºï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (sortBy === "amount") {
      result.sort((a, b) => {
        return sortOrder === "asc" 
          ? a.amount - b.amount 
          : b.amount - a.amount;
      });
    }

    // ğŸ“Š è®¡ç®—æ€»é¡µæ•°
    const totalPages = Math.ceil(total / pageSize);

    return NextResponse.json({
      ok: true,
      data: result,
      pagination: {
        page,
        pageSize,
        total,
        totalPages,
      },
    });
  } catch (e: any) {
    console.error("[ORDER_LIST_ERROR] âŒ", e);
    return NextResponse.json(
      {
        ok: false,
        code: "SERVER_ERROR",
        message: "æŸ¥è¯¢è®¢å•å¤±è´¥",
      },
      { status: 500 }
    );
  }
}

// âœ… åˆ›å»ºè®¢å•ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ä¸å˜ï¼‰
export async function POST(req: Request) {
  try {
    const now = Date.now();
    await purgeExpiredHolds(now);

    const body = await req.json().catch(() => ({}));
    const { eventId, tierId, qty, holdId } = body || {};

    console.log(`[ORDER_CREATE] ğŸ“ æ”¶åˆ°åˆ›å»ºè¯·æ±‚:`, { eventId, tierId, qty, holdId });

    // 1ï¸âƒ£ å‚æ•°æ ¡éªŒ
    if (
      eventId == null ||
      tierId == null ||
      !holdId ||
      typeof qty !== "number" ||
      !Number.isInteger(qty) ||
      qty <= 0
    ) {
      console.warn(`[ORDER_CREATE] âŒ å‚æ•°æ ¡éªŒå¤±è´¥`);
      return NextResponse.json(
        {
          ok: false,
          code: "BAD_REQUEST",
          message: "è¯·æ±‚å‚æ•°é”™è¯¯ï¼Œè¯·æ£€æŸ¥åé‡è¯•ã€‚",
        },
        { status: 400 }
      );
    }

    // 2ï¸âƒ£ ç»Ÿä¸€ ID å¤„ç†
    const normalizedEventId = normalizeId(eventId);
    const normalizedTierId = normalizeId(tierId);
    const normalizedHoldId = normalizeId(holdId);

    // 3ï¸âƒ£ éªŒè¯ hold å­˜åœ¨æ€§
    const hold = await prisma.hold.findUnique({
      where: { id: normalizedHoldId },
    });

    if (!hold) {
      console.warn(`[ORDER_CREATE] âŒ hold ä¸å­˜åœ¨ï¼šholdId=${normalizedHoldId}`);
      return NextResponse.json(
        {
          ok: false,
          code: "HOLD_NOT_FOUND",
          message: "é”ç¥¨ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°é€‰æ‹©ç¥¨æ¡£å¹¶ä¸‹å•ã€‚",
        },
        { status: 404 }
      );
    }

    // 4ï¸âƒ£ éªŒè¯ hold æ˜¯å¦è¿‡æœŸ
    if (Number(hold.expireAt) <= now) {
      console.warn(`[ORDER_CREATE] âŒ hold å·²è¿‡æœŸï¼šholdId=${normalizedHoldId}`);
      return NextResponse.json(
        {
          ok: false,
          code: "HOLD_EXPIRED",
          message: "é”ç¥¨å·²è¿‡æœŸï¼Œè¯·é‡æ–°é€‰æ‹©ç¥¨æ¡£å¹¶ä¸‹å•ã€‚",
        },
        { status: 410 }
      );
    }

    // 5ï¸âƒ£ ä¸€è‡´æ€§æ ¡éªŒ
    if (
      hold.eventId !== normalizedEventId ||
      hold.tierId !== normalizedTierId ||
      hold.qty !== qty
    ) {
      console.warn(`[ORDER_CREATE] âŒ è®¢å•ä¸é”ç¥¨ä¸ä¸€è‡´`);
      return NextResponse.json(
        {
          ok: false,
          code: "ORDER_HOLD_MISMATCH",
          message: "è®¢å•ä¿¡æ¯ä¸é”ç¥¨ä¸ä¸€è‡´ï¼Œè¯·è¿”å›é‡æ–°ä¸‹å•ã€‚",
        },
        { status: 400 }
      );
    }

    // 6ï¸âƒ£ åˆ›å»ºè®¢å•
    const orderId = genId("O");
    await prisma.order.create({
      data: {
        id: orderId,
        eventId: normalizedEventId,
        tierId: normalizedTierId,
        qty: qty,
        status: "PENDING",
        createdAt: BigInt(now),
        paidAt: null,
        holdId: normalizedHoldId,
      },
    });

    console.log(`[ORDER_CREATE] âœ… è®¢å•åˆ›å»ºæˆåŠŸï¼šorderId=${orderId}`);

    return NextResponse.json({
      ok: true,
      data: {
        orderId,
        status: "PENDING",
        createdAt: now,
      },
    });
  } catch (err: any) {
    console.error("[ORDER_CREATE_ERROR] âŒ", err);

    if (err instanceof ApiError) {
      return NextResponse.json(
        {
          ok: false,
          code: err.code,
          message: err.message,
          data: err.data,
        },
        { status: err.status }
      );
    }

    return NextResponse.json(
      {
        ok: false,
        code: "INTERNAL_ERROR",
        message: "æœåŠ¡ç¹å¿™ï¼Œè¯·ç¨åé‡è¯•ã€‚",
      },
      { status: 500 }
    );
  }
}